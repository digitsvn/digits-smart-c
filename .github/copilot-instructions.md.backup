# Copilot instructions (py-xiaozhi-pi)

## Quick start / run
- Entry point: [main.py](main.py) (GUI default) or `python main.py --mode cli`.
- Protocols: support both `--protocol websocket` (default) and `--protocol mqtt`.
- First-run bootstrap: activation + OTA config are coordinated by `SystemInitializer` in [src/core/system_initializer.py](src/core/system_initializer.py).

## Architecture (how data flows)
- `Application` is a singleton orchestrator ([src/application.py](src/application.py)). It owns:
  - the selected `Protocol` (`WebsocketProtocol` / `MqttProtocol`),
  - the device state machine (`DeviceState`, `ListeningMode`),
  - a task registry via `Application.spawn(...)` for fire-and-forget async work.
- Plugins are the extension boundary: registered in `Application.run()` and managed by `PluginManager` ([src/plugins/manager.py](src/plugins/manager.py)).
  - Plugin lifecycle is `setup()` → `start()` → `stop()` → `shutdown()` ([src/plugins/base.py](src/plugins/base.py)).
  - Errors inside plugins are intentionally isolated (exceptions are swallowed), so log/validate inside the plugin if behavior matters.
- Protocol events are callbacks set by `Application._setup_protocol_callbacks()` and then broadcast to plugins:
  - binary audio → `plugins.notify_incoming_audio(...)`
  - JSON messages → `plugins.notify_incoming_json(...)`
  - UI state is derived from `tts start/stop` inside `Application._on_incoming_json()`.

## Config, files, and runtime paths
- Config lives in `config/config.json` (auto-created/merged) via `ConfigManager` ([src/utils/config_manager.py](src/utils/config_manager.py)).
- Device identity + activation status are stored in `config/efuse.json` via `DeviceFingerprint` ([src/utils/device_fingerprint.py](src/utils/device_fingerprint.py)).
- Use `resource_finder` helpers for paths across dev vs PyInstaller packaging ([src/utils/resource_finder.py](src/utils/resource_finder.py)).

## Audio stack (common pitfalls)
- Audio runs through `AudioPlugin` + `AudioCodec` ([src/plugins/audio.py](src/plugins/audio.py), [src/audio_codecs/audio_codec.py](src/audio_codecs/audio_codec.py)).
- Opus native lib must be loadable at runtime; it’s set up early in `Application` via `setup_opus()` ([src/utils/opus_loader.py](src/utils/opus_loader.py)) using `libs/libopus/...`.
- To debug non-audio features without sound devices: set `XIAOZHI_DISABLE_AUDIO=1`.
- Frame duration adapts for ARM devices (e.g. Raspberry Pi) in `AudioConfig.FRAME_DURATION` ([src/constants/constants.py](src/constants/constants.py)).

## GUI (QML) + video integration
- GUI is PyQt5 + QML: `UIPlugin(mode="gui")` instantiates `GuiDisplay` ([src/plugins/ui.py](src/plugins/ui.py), [src/display/gui_display.py](src/display/gui_display.py)) which loads [src/display/gui_display.qml](src/display/gui_display.qml) into a `QQuickWidget`.
- Data binding uses `GuiDisplayModel` properties/signals ([src/display/gui_display_model.py](src/display/gui_display_model.py)); updating the model is the preferred way to change UI state.
- Camera code today is snapshot-based (captures a single JPEG via OpenCV) under [src/mcp/tools/camera](src/mcp/tools/camera) and is primarily wired for “take photo + analyze”, not continuous streaming.
- To show live video inside the GUI frame, add a new image-like property to `GuiDisplayModel` (e.g. `videoFrameUrl`) and render it in QML as an `Image`/`AnimatedImage`; update it from `GuiDisplay` on a `QTimer` (don’t block the asyncio loop).

## MCP server/tools
- MCP server is implemented in [src/mcp/mcp_server.py](src/mcp/mcp_server.py) and registers tool bundles from `src/mcp/tools/*` via `add_common_tools()`.
- When adding a tool: follow `McpTool(name, description, PropertyList, callback)` and return simple values (bool/int/str) for consistent JSON formatting.

## Conventions when changing code
- Prefer scheduling work onto the main loop via `Application.spawn(...)` or `schedule_command_nowait(...)` (don’t `create_task` ad-hoc in plugins).
- When touching state transitions, update `Application.set_device_state(...)` and rely on plugin broadcast (`notify_device_state_changed`).
